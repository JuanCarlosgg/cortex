// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file DSRGraph.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "DSRGraph.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

IDL::Val::Val()
{
    m__d = 0;
    // m_str com.eprosima.idl.parser.typecode.StringTypeCode@4cf4d528
    m_str ="";
    // m_dec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@77846d2c
    m_dec = 0;
    // m_fl com.eprosima.idl.parser.typecode.PrimitiveTypeCode@548ad73b
    m_fl = 0.0;
    // m_float_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@4c762604

    // m_bl com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2641e737
    m_bl = false;
    // m_byte_vec com.eprosima.idl.parser.typecode.SequenceTypeCode@727803de

}

IDL::Val::~Val()
{
}

IDL::Val::Val(const Val &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_str = x.m_str;
        break;
        case 1:
        m_dec = x.m_dec;
        break;
        case 2:
        m_fl = x.m_fl;
        break;
        case 3:
        m_float_vec = x.m_float_vec;
        break;
        case 4:
        m_bl = x.m_bl;
        break;
        case 5:
        m_byte_vec = x.m_byte_vec;
        break;
        default:
        break;
    }
}

IDL::Val::Val(Val &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_str = std::move(x.m_str);
        break;
        case 1:
        m_dec = x.m_dec;
        break;
        case 2:
        m_fl = x.m_fl;
        break;
        case 3:
        m_float_vec = std::move(x.m_float_vec);
        break;
        case 4:
        m_bl = x.m_bl;
        break;
        case 5:
        m_byte_vec = std::move(x.m_byte_vec);
        break;
        default:
        break;
    }
}

IDL::Val& IDL::Val::operator=(const Val &x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_str = x.m_str;
        break;
        case 1:
        m_dec = x.m_dec;
        break;
        case 2:
        m_fl = x.m_fl;
        break;
        case 3:
        m_float_vec = x.m_float_vec;
        break;
        case 4:
        m_bl = x.m_bl;
        break;
        case 5:
        m_byte_vec = x.m_byte_vec;
        break;
        default:
        break;
    }

    return *this;
}

IDL::Val& IDL::Val::operator=(Val &&x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case 0:
        m_str = std::move(x.m_str);
        break;
        case 1:
        m_dec = x.m_dec;
        break;
        case 2:
        m_fl = x.m_fl;
        break;
        case 3:
        m_float_vec = std::move(x.m_float_vec);
        break;
        case 4:
        m_bl = x.m_bl;
        break;
        case 5:
        m_byte_vec = std::move(x.m_byte_vec);
        break;
        default:
        break;
    }

    return *this;
}

void IDL::Val::_d(int32_t __d)
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 2:
        switch(__d)
        {
            case 2:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 3:
        switch(__d)
        {
            case 3:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 4:
        switch(__d)
        {
            case 4:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 5:
        switch(__d)
        {
            case 5:
            b = true;
            break;
            default:
            break;
        }
        break;
    }

    if(!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t IDL::Val::_d() const
{
    return m__d;
}

int32_t& IDL::Val::_d()
{
    return m__d;
}

void IDL::Val::str(const std::string &_str)
{
    m_str = _str;
    m__d = 0;
}

void IDL::Val::str(std::string &&_str)
{
    m_str = std::move(_str);
    m__d = 0;
}

const std::string& IDL::Val::str() const
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_str;
}

std::string& IDL::Val::str()
{
    bool b = false;

    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_str;
}
void IDL::Val::dec(int32_t _dec)
{
    m_dec = _dec;
    m__d = 1;
}

int32_t IDL::Val::dec() const
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_dec;
}

int32_t& IDL::Val::dec()
{
    bool b = false;

    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_dec;
}
void IDL::Val::fl(float _fl)
{
    m_fl = _fl;
    m__d = 2;
}

float IDL::Val::fl() const
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_fl;
}

float& IDL::Val::fl()
{
    bool b = false;

    switch(m__d)
    {
        case 2:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_fl;
}
void IDL::Val::float_vec(const std::vector<float> &_float_vec)
{
    m_float_vec = _float_vec;
    m__d = 3;
}

void IDL::Val::float_vec(std::vector<float> &&_float_vec)
{
    m_float_vec = std::move(_float_vec);
    m__d = 3;
}

const std::vector<float>& IDL::Val::float_vec() const
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_float_vec;
}

std::vector<float>& IDL::Val::float_vec()
{
    bool b = false;

    switch(m__d)
    {
        case 3:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_float_vec;
}
void IDL::Val::bl(bool _bl)
{
    m_bl = _bl;
    m__d = 4;
}

bool IDL::Val::bl() const
{
    bool b = false;

    switch(m__d)
    {
        case 4:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_bl;
}

bool& IDL::Val::bl()
{
    bool b = false;

    switch(m__d)
    {
        case 4:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_bl;
}
void IDL::Val::byte_vec(const std::vector<uint8_t> &_byte_vec)
{
    m_byte_vec = _byte_vec;
    m__d = 5;
}

void IDL::Val::byte_vec(std::vector<uint8_t> &&_byte_vec)
{
    m_byte_vec = std::move(_byte_vec);
    m__d = 5;
}

const std::vector<uint8_t>& IDL::Val::byte_vec() const
{
    bool b = false;

    switch(m__d)
    {
        case 5:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_byte_vec;
}

std::vector<uint8_t>& IDL::Val::byte_vec()
{
    bool b = false;

    switch(m__d)
    {
        case 5:
        b = true;
        break;
        default:
        break;
    }
    if(!b)
    {
        throw BadParamException("This member is not been selected");
    }

    return m_byte_vec;
}

size_t IDL::Val::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);



        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);

        reset_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);



        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;



    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t IDL::Val::getCdrSerializedSize(const Val& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case 0:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.str().size() + 1;
        break;
        case 1:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 2:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        break;
        case 3:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += (data.float_vec().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        break;
        case 4:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        case 5:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

        current_alignment += (data.byte_vec().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void IDL::Val::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 0:
        scdr << m_str;
        break;
        case 1:
        scdr << m_dec;
        break;
        case 2:
        scdr << m_fl;
        break;
        case 3:
        scdr << m_float_vec;break;
        case 4:
        scdr << m_bl;
        break;
        case 5:
        scdr << m_byte_vec;break;
        default:
        break;
    }
}

void IDL::Val::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 0:
        dcdr >> m_str;
        break;
        case 1:
        dcdr >> m_dec;
        break;
        case 2:
        dcdr >> m_fl;
        break;
        case 3:
        dcdr >> m_float_vec;break;
        case 4:
        dcdr >> m_bl;
        break;
        case 5:
        dcdr >> m_byte_vec;break;
        default:
        break;
    }
}



IDL::Attrib::Attrib()
{
    // m_type com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6a472554
    m_type = 0;
    // m_value com.eprosima.idl.parser.typecode.UnionTypeCode@7ff2a664

    // m_timestamp com.eprosima.idl.parser.typecode.PrimitiveTypeCode@525b461a
    m_timestamp = 0;

}

IDL::Attrib::~Attrib()
{



}

IDL::Attrib::Attrib(const Attrib &x)
{
    m_type = x.m_type;
    m_value = x.m_value;
    m_timestamp = x.m_timestamp;
}

IDL::Attrib::Attrib(Attrib &&x)
{
    m_type = x.m_type;
    m_value = std::move(x.m_value);
    m_timestamp = x.m_timestamp;
}

IDL::Attrib& IDL::Attrib::operator=(const Attrib &x)
{

    m_type = x.m_type;
    m_value = x.m_value;
    m_timestamp = x.m_timestamp;

    return *this;
}

IDL::Attrib& IDL::Attrib::operator=(Attrib &&x)
{

    m_type = x.m_type;
    m_value = std::move(x.m_value);
    m_timestamp = x.m_timestamp;

    return *this;
}

size_t IDL::Attrib::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += Val::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t IDL::Attrib::getCdrSerializedSize(const Attrib& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += Val::getCdrSerializedSize(data.value(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void IDL::Attrib::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_type;
    scdr << m_value;
    scdr << m_timestamp;
}

void IDL::Attrib::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_type;
    dcdr >> m_value;
    dcdr >> m_timestamp;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void IDL::Attrib::type(int32_t _type)
{
m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
int32_t IDL::Attrib::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
int32_t& IDL::Attrib::type()
{
    return m_type;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void IDL::Attrib::value(const Val &_value)
{
m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void IDL::Attrib::value(Val &&_value)
{
m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const IDL::Val& IDL::Attrib::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
IDL::Val& IDL::Attrib::value()
{
    return m_value;
}
/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void IDL::Attrib::timestamp(uint64_t _timestamp)
{
m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t IDL::Attrib::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& IDL::Attrib::timestamp()
{
    return m_timestamp;
}


size_t IDL::Attrib::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool IDL::Attrib::isKeyDefined()
{
   return false;
}

void IDL::Attrib::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;



}

IDL::Edge::Edge()
{
    // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@429bd883
    m_to = 0;
    // m_type com.eprosima.idl.parser.typecode.StringTypeCode@4d49af10
    m_type ="";
    // m_from com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4450d156
    m_from = 0;
    // m_attrs com.eprosima.idl.parser.typecode.MapTypeCode@4461c7e3


}

IDL::Edge::~Edge()
{




}

IDL::Edge::Edge(const Edge &x)
{
    m_to = x.m_to;
    m_type = x.m_type;
    m_from = x.m_from;
    m_attrs = x.m_attrs;
}

IDL::Edge::Edge(Edge &&x)
{
    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_from = x.m_from;
    m_attrs = std::move(x.m_attrs);
}

IDL::Edge& IDL::Edge::operator=(const Edge &x)
{

    m_to = x.m_to;
    m_type = x.m_type;
    m_from = x.m_from;
    m_attrs = x.m_attrs;

    return *this;
}

IDL::Edge& IDL::Edge::operator=(Edge &&x)
{

    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_from = x.m_from;
    m_attrs = std::move(x.m_attrs);

    return *this;
}

size_t IDL::Edge::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


        current_alignment += Attrib::getMaxCdrSerializedSize(current_alignment);
    }


    return current_alignment - initial_alignment;
}

size_t IDL::Edge::getCdrSerializedSize(const Edge& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.attrs())
    {
        (void)a;
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + a.first.size() + 1;
        current_alignment += Attrib::getCdrSerializedSize((a.second), current_alignment);

    }



    return current_alignment - initial_alignment;
}

void IDL::Edge::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_to;
    scdr << m_type;
    scdr << m_from;
    scdr << m_attrs;
}

void IDL::Edge::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_to;
    dcdr >> m_type;
    dcdr >> m_from;
    dcdr >> m_attrs;
}

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
void IDL::Edge::to(int32_t _to)
{
m_to = _to;
}

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
int32_t IDL::Edge::to() const
{
    return m_to;
}

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
int32_t& IDL::Edge::to()
{
    return m_to;
}

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void IDL::Edge::type(const std::string &_type)
{
m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void IDL::Edge::type(std::string &&_type)
{
m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& IDL::Edge::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& IDL::Edge::type()
{
    return m_type;
}
/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
void IDL::Edge::from(int32_t _from)
{
m_from = _from;
}

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
int32_t IDL::Edge::from() const
{
    return m_from;
}

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
int32_t& IDL::Edge::from()
{
    return m_from;
}

/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
void IDL::Edge::attrs(const std::map<std::string, Attrib> &_attrs)
{
m_attrs = _attrs;
}

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
void IDL::Edge::attrs(std::map<std::string, Attrib> &&_attrs)
{
m_attrs = std::move(_attrs);
}

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
const std::map<std::string, IDL::Attrib>& IDL::Edge::attrs() const
{
    return m_attrs;
}

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
std::map<std::string, IDL::Attrib>& IDL::Edge::attrs()
{
    return m_attrs;
}

size_t IDL::Edge::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool IDL::Edge::isKeyDefined()
{
   return false;
}

void IDL::Edge::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;




}

IDL::EdgeKey::EdgeKey()
{
    // m_to com.eprosima.idl.parser.typecode.PrimitiveTypeCode@255b53dc
    m_to = 0;
    // m_type com.eprosima.idl.parser.typecode.StringTypeCode@1dd92fe2
    m_type ="";

}

IDL::EdgeKey::~EdgeKey()
{


}

IDL::EdgeKey::EdgeKey(const EdgeKey &x)
{
    m_to = x.m_to;
    m_type = x.m_type;
}

IDL::EdgeKey::EdgeKey(EdgeKey &&x)
{
    m_to = x.m_to;
    m_type = std::move(x.m_type);
}

IDL::EdgeKey& IDL::EdgeKey::operator=(const EdgeKey &x)
{

    m_to = x.m_to;
    m_type = x.m_type;

    return *this;
}

IDL::EdgeKey& IDL::EdgeKey::operator=(EdgeKey &&x)
{

    m_to = x.m_to;
    m_type = std::move(x.m_type);

    return *this;
}

size_t IDL::EdgeKey::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t IDL::EdgeKey::getCdrSerializedSize(const EdgeKey& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;


    return current_alignment - initial_alignment;
}

void IDL::EdgeKey::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_to;
    scdr << m_type;
}

void IDL::EdgeKey::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_to;
    dcdr >> m_type;
}

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
void IDL::EdgeKey::to(int32_t _to)
{
m_to = _to;
}

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
int32_t IDL::EdgeKey::to() const
{
    return m_to;
}

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
int32_t& IDL::EdgeKey::to()
{
    return m_to;
}

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void IDL::EdgeKey::type(const std::string &_type)
{
m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void IDL::EdgeKey::type(std::string &&_type)
{
m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& IDL::EdgeKey::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& IDL::EdgeKey::type()
{
    return m_type;
}

size_t IDL::EdgeKey::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool IDL::EdgeKey::isKeyDefined()
{
   return false;
}

void IDL::EdgeKey::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;


}

IDL::Node::Node()
{
    // m_type com.eprosima.idl.parser.typecode.StringTypeCode@176d53b2
    m_type ="";
    // m_name com.eprosima.idl.parser.typecode.StringTypeCode@971d0d8
    m_name ="";
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@51931956
    m_id = 0;
    // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@2b4a2ec7
    m_agent_id = 0;
    // m_attrs com.eprosima.idl.parser.typecode.MapTypeCode@564718df

    // m_fano com.eprosima.idl.parser.typecode.MapTypeCode@51b7e5df


}

IDL::Node::~Node()
{






}

IDL::Node::Node(const Node &x)
{
    m_type = x.m_type;
    m_name = x.m_name;
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = x.m_attrs;
    m_fano = x.m_fano;
}

IDL::Node::Node(Node &&x)
{
    m_type = std::move(x.m_type);
    m_name = std::move(x.m_name);
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = std::move(x.m_attrs);
    m_fano = std::move(x.m_fano);
}

IDL::Node& IDL::Node::operator=(const Node &x)
{

    m_type = x.m_type;
    m_name = x.m_name;
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = x.m_attrs;
    m_fano = x.m_fano;

    return *this;
}

IDL::Node& IDL::Node::operator=(Node &&x)
{

    m_type = std::move(x.m_type);
    m_name = std::move(x.m_name);
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = std::move(x.m_attrs);
    m_fano = std::move(x.m_fano);

    return *this;
}

size_t IDL::Node::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


        current_alignment += Attrib::getMaxCdrSerializedSize(current_alignment);
    }

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += EdgeKey::getMaxCdrSerializedSize(current_alignment);

        current_alignment += Edge::getMaxCdrSerializedSize(current_alignment);
    }


    return current_alignment - initial_alignment;
}

size_t IDL::Node::getCdrSerializedSize(const Node& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.attrs())
    {
        (void)a;
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + a.first.size() + 1;
        current_alignment += Attrib::getCdrSerializedSize((a.second), current_alignment);

    }


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.fano())
    {
        (void)a;
        current_alignment += EdgeKey::getCdrSerializedSize((a.first), current_alignment);
        current_alignment += Edge::getCdrSerializedSize((a.second), current_alignment);

    }



    return current_alignment - initial_alignment;
}

void IDL::Node::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_type;
    scdr << m_name;
    scdr << m_id;
    scdr << m_agent_id;
    scdr << m_attrs;
    scdr << m_fano;
}

void IDL::Node::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_type;
    dcdr >> m_name;
    dcdr >> m_id;
    dcdr >> m_agent_id;
    dcdr >> m_attrs;
    dcdr >> m_fano;
}

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void IDL::Node::type(const std::string &_type)
{
m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void IDL::Node::type(std::string &&_type)
{
m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& IDL::Node::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& IDL::Node::type()
{
    return m_type;
}
/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void IDL::Node::name(const std::string &_name)
{
m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void IDL::Node::name(std::string &&_name)
{
m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& IDL::Node::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& IDL::Node::name()
{
    return m_name;
}
/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void IDL::Node::id(int32_t _id)
{
m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t IDL::Node::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& IDL::Node::id()
{
    return m_id;
}

/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void IDL::Node::agent_id(int32_t _agent_id)
{
m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
int32_t IDL::Node::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
int32_t& IDL::Node::agent_id()
{
    return m_agent_id;
}

/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
void IDL::Node::attrs(const std::map<std::string, Attrib> &_attrs)
{
m_attrs = _attrs;
}

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
void IDL::Node::attrs(std::map<std::string, Attrib> &&_attrs)
{
m_attrs = std::move(_attrs);
}

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
const std::map<std::string, IDL::Attrib>& IDL::Node::attrs() const
{
    return m_attrs;
}

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
std::map<std::string, IDL::Attrib>& IDL::Node::attrs()
{
    return m_attrs;
}
/*!
 * @brief This function copies the value in member fano
 * @param _fano New value to be copied in member fano
 */
void IDL::Node::fano(const std::map<EdgeKey, Edge> &_fano)
{
m_fano = _fano;
}

/*!
 * @brief This function moves the value in member fano
 * @param _fano New value to be moved in member fano
 */
void IDL::Node::fano(std::map<EdgeKey, Edge> &&_fano)
{
m_fano = std::move(_fano);
}

/*!
 * @brief This function returns a constant reference to member fano
 * @return Constant reference to member fano
 */
const std::map<IDL::EdgeKey, IDL::Edge>& IDL::Node::fano() const
{
    return m_fano;
}

/*!
 * @brief This function returns a reference to member fano
 * @return Reference to member fano
 */
std::map<IDL::EdgeKey, IDL::Edge>& IDL::Node::fano()
{
    return m_fano;
}

size_t IDL::Node::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;









    return current_align;
}

bool IDL::Node::isKeyDefined()
{
   return false;
}

void IDL::Node::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;






}

IDL::GraphRequest::GraphRequest()
{
    // m_from com.eprosima.idl.parser.typecode.StringTypeCode@c540f5a
    m_from ="";

}

IDL::GraphRequest::~GraphRequest()
{
}

IDL::GraphRequest::GraphRequest(const GraphRequest &x)
{
    m_from = x.m_from;
}

IDL::GraphRequest::GraphRequest(GraphRequest &&x)
{
    m_from = std::move(x.m_from);
}

IDL::GraphRequest& IDL::GraphRequest::operator=(const GraphRequest &x)
{

    m_from = x.m_from;

    return *this;
}

IDL::GraphRequest& IDL::GraphRequest::operator=(GraphRequest &&x)
{

    m_from = std::move(x.m_from);

    return *this;
}

size_t IDL::GraphRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t IDL::GraphRequest::getCdrSerializedSize(const GraphRequest& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.from().size() + 1;

    return current_alignment - initial_alignment;
}

void IDL::GraphRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_from;
}

void IDL::GraphRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_from;
}

/*!
 * @brief This function copies the value in member from
 * @param _from New value to be copied in member from
 */
void IDL::GraphRequest::from(const std::string &_from)
{
m_from = _from;
}

/*!
 * @brief This function moves the value in member from
 * @param _from New value to be moved in member from
 */
void IDL::GraphRequest::from(std::string &&_from)
{
m_from = std::move(_from);
}

/*!
 * @brief This function returns a constant reference to member from
 * @return Constant reference to member from
 */
const std::string& IDL::GraphRequest::from() const
{
    return m_from;
}

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
std::string& IDL::GraphRequest::from()
{
    return m_from;
}

size_t IDL::GraphRequest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool IDL::GraphRequest::isKeyDefined()
{
   return false;
}

void IDL::GraphRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;

}

IDL::PairInt::PairInt()
{
    // m_first com.eprosima.idl.parser.typecode.PrimitiveTypeCode@77e9807f
    m_first = 0;
    // m_second com.eprosima.idl.parser.typecode.PrimitiveTypeCode@448ff1a8
    m_second = 0;

}

IDL::PairInt::~PairInt()
{


}

IDL::PairInt::PairInt(const PairInt &x)
{
    m_first = x.m_first;
    m_second = x.m_second;
}

IDL::PairInt::PairInt(PairInt &&x)
{
    m_first = x.m_first;
    m_second = x.m_second;
}

IDL::PairInt& IDL::PairInt::operator=(const PairInt &x)
{

    m_first = x.m_first;
    m_second = x.m_second;

    return *this;
}

IDL::PairInt& IDL::PairInt::operator=(PairInt &&x)
{

    m_first = x.m_first;
    m_second = x.m_second;

    return *this;
}

size_t IDL::PairInt::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t IDL::PairInt::getCdrSerializedSize(const PairInt& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void IDL::PairInt::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_first;
    scdr << m_second;
}

void IDL::PairInt::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_first;
    dcdr >> m_second;
}

/*!
 * @brief This function sets a value in member first
 * @param _first New value for member first
 */
void IDL::PairInt::first(int32_t _first)
{
m_first = _first;
}

/*!
 * @brief This function returns the value of member first
 * @return Value of member first
 */
int32_t IDL::PairInt::first() const
{
    return m_first;
}

/*!
 * @brief This function returns a reference to member first
 * @return Reference to member first
 */
int32_t& IDL::PairInt::first()
{
    return m_first;
}

/*!
 * @brief This function sets a value in member second
 * @param _second New value for member second
 */
void IDL::PairInt::second(int32_t _second)
{
m_second = _second;
}

/*!
 * @brief This function returns the value of member second
 * @return Value of member second
 */
int32_t IDL::PairInt::second() const
{
    return m_second;
}

/*!
 * @brief This function returns a reference to member second
 * @return Reference to member second
 */
int32_t& IDL::PairInt::second()
{
    return m_second;
}


size_t IDL::PairInt::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool IDL::PairInt::isKeyDefined()
{
   return false;
}

void IDL::PairInt::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;


}

IDL::DotContext::DotContext()
{
    // m_cc com.eprosima.idl.parser.typecode.MapTypeCode@44a664f2

    // m_dc com.eprosima.idl.parser.typecode.SequenceTypeCode@7f9fcf7f


}

IDL::DotContext::~DotContext()
{


}

IDL::DotContext::DotContext(const DotContext &x)
{
    m_cc = x.m_cc;
    m_dc = x.m_dc;
}

IDL::DotContext::DotContext(DotContext &&x)
{
    m_cc = std::move(x.m_cc);
    m_dc = std::move(x.m_dc);
}

IDL::DotContext& IDL::DotContext::operator=(const DotContext &x)
{

    m_cc = x.m_cc;
    m_dc = x.m_dc;

    return *this;
}

IDL::DotContext& IDL::DotContext::operator=(DotContext &&x)
{

    m_cc = std::move(x.m_cc);
    m_dc = std::move(x.m_dc);

    return *this;
}

size_t IDL::DotContext::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    }

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t IDL::DotContext::getCdrSerializedSize(const DotContext& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.cc())
    {
        (void)a;
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    }


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.dc().size(); ++a)
    {
        current_alignment += PairInt::getCdrSerializedSize(data.dc().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void IDL::DotContext::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_cc;
    scdr << m_dc;
}

void IDL::DotContext::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_cc;
    dcdr >> m_dc;
}

/*!
 * @brief This function copies the value in member cc
 * @param _cc New value to be copied in member cc
 */
void IDL::DotContext::cc(const std::map<int32_t, int32_t> &_cc)
{
m_cc = _cc;
}

/*!
 * @brief This function moves the value in member cc
 * @param _cc New value to be moved in member cc
 */
void IDL::DotContext::cc(std::map<int32_t, int32_t> &&_cc)
{
m_cc = std::move(_cc);
}

/*!
 * @brief This function returns a constant reference to member cc
 * @return Constant reference to member cc
 */
const std::map<int32_t, int32_t>& IDL::DotContext::cc() const
{
    return m_cc;
}

/*!
 * @brief This function returns a reference to member cc
 * @return Reference to member cc
 */
std::map<int32_t, int32_t>& IDL::DotContext::cc()
{
    return m_cc;
}
/*!
 * @brief This function copies the value in member dc
 * @param _dc New value to be copied in member dc
 */
void IDL::DotContext::dc(const std::vector<PairInt> &_dc)
{
m_dc = _dc;
}

/*!
 * @brief This function moves the value in member dc
 * @param _dc New value to be moved in member dc
 */
void IDL::DotContext::dc(std::vector<PairInt> &&_dc)
{
m_dc = std::move(_dc);
}

/*!
 * @brief This function returns a constant reference to member dc
 * @return Constant reference to member dc
 */
const std::vector<IDL::PairInt>& IDL::DotContext::dc() const
{
    return m_dc;
}

/*!
 * @brief This function returns a reference to member dc
 * @return Reference to member dc
 */
std::vector<IDL::PairInt>& IDL::DotContext::dc()
{
    return m_dc;
}

size_t IDL::DotContext::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool IDL::DotContext::isKeyDefined()
{
   return false;
}

void IDL::DotContext::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;


}

IDL::DotKernel::DotKernel()
{
    // m_ds com.eprosima.idl.parser.typecode.MapTypeCode@41ee392b

    // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@1e67a849


}

IDL::DotKernel::~DotKernel()
{


}

IDL::DotKernel::DotKernel(const DotKernel &x)
{
    m_ds = x.m_ds;
    m_cbase = x.m_cbase;
}

IDL::DotKernel::DotKernel(DotKernel &&x)
{
    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);
}

IDL::DotKernel& IDL::DotKernel::operator=(const DotKernel &x)
{

    m_ds = x.m_ds;
    m_cbase = x.m_cbase;

    return *this;
}

IDL::DotKernel& IDL::DotKernel::operator=(DotKernel &&x)
{

    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);

    return *this;
}

size_t IDL::DotKernel::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += PairInt::getMaxCdrSerializedSize(current_alignment);

        current_alignment += Node::getMaxCdrSerializedSize(current_alignment);
    }

    current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t IDL::DotKernel::getCdrSerializedSize(const DotKernel& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.ds())
    {
        (void)a;
        current_alignment += PairInt::getCdrSerializedSize((a.first), current_alignment);
        current_alignment += Node::getCdrSerializedSize((a.second), current_alignment);

    }


    current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

    return current_alignment - initial_alignment;
}

void IDL::DotKernel::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_ds;
    scdr << m_cbase;
}

void IDL::DotKernel::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_ds;
    dcdr >> m_cbase;
}

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
void IDL::DotKernel::ds(const std::map<PairInt, Node> &_ds)
{
m_ds = _ds;
}

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
void IDL::DotKernel::ds(std::map<PairInt, Node> &&_ds)
{
m_ds = std::move(_ds);
}

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
const std::map<IDL::PairInt, IDL::Node>& IDL::DotKernel::ds() const
{
    return m_ds;
}

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
std::map<IDL::PairInt, IDL::Node>& IDL::DotKernel::ds()
{
    return m_ds;
}
/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
void IDL::DotKernel::cbase(const DotContext &_cbase)
{
m_cbase = _cbase;
}

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
void IDL::DotKernel::cbase(DotContext &&_cbase)
{
m_cbase = std::move(_cbase);
}

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
const IDL::DotContext& IDL::DotKernel::cbase() const
{
    return m_cbase;
}

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
IDL::DotContext& IDL::DotKernel::cbase()
{
    return m_cbase;
}

size_t IDL::DotKernel::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool IDL::DotKernel::isKeyDefined()
{
   return false;
}

void IDL::DotKernel::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;


}

IDL::Mvreg::Mvreg()
{
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@36f0f1be
    m_id = 0;
    // m_dk com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@157632c9

    // m_agent_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6ee12bac
    m_agent_id = 0;

}

IDL::Mvreg::~Mvreg()
{



}

IDL::Mvreg::Mvreg(const Mvreg &x)
{
    m_id = x.m_id;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
}

IDL::Mvreg::Mvreg(Mvreg &&x)
{
    m_id = x.m_id;
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
}

IDL::Mvreg& IDL::Mvreg::operator=(const Mvreg &x)
{

    m_id = x.m_id;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;

    return *this;
}

IDL::Mvreg& IDL::Mvreg::operator=(Mvreg &&x)
{

    m_id = x.m_id;
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;

    return *this;
}

size_t IDL::Mvreg::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += DotKernel::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t IDL::Mvreg::getCdrSerializedSize(const Mvreg& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += DotKernel::getCdrSerializedSize(data.dk(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void IDL::Mvreg::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_dk;
    scdr << m_agent_id;
}

void IDL::Mvreg::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_dk;
    dcdr >> m_agent_id;
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void IDL::Mvreg::id(int32_t _id)
{
m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t IDL::Mvreg::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& IDL::Mvreg::id()
{
    return m_id;
}

/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
void IDL::Mvreg::dk(const DotKernel &_dk)
{
m_dk = _dk;
}

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
void IDL::Mvreg::dk(DotKernel &&_dk)
{
m_dk = std::move(_dk);
}

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
const IDL::DotKernel& IDL::Mvreg::dk() const
{
    return m_dk;
}

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
IDL::DotKernel& IDL::Mvreg::dk()
{
    return m_dk;
}
/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void IDL::Mvreg::agent_id(int32_t _agent_id)
{
m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
int32_t IDL::Mvreg::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
int32_t& IDL::Mvreg::agent_id()
{
    return m_agent_id;
}


size_t IDL::Mvreg::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool IDL::Mvreg::isKeyDefined()
{
   return false;
}

void IDL::Mvreg::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;



}

IDL::OrMap::OrMap()
{
    // m_id com.eprosima.idl.parser.typecode.PrimitiveTypeCode@400cff1a
    m_id = 0;
    // m_m com.eprosima.idl.parser.typecode.MapTypeCode@275710fc

    // m_cbase com.eprosima.fastrtps.idl.parser.typecode.StructTypeCode@1e67a849


}

IDL::OrMap::~OrMap()
{



}

IDL::OrMap::OrMap(const OrMap &x)
{
    m_id = x.m_id;
    m_m = x.m_m;
    m_cbase = x.m_cbase;
}

IDL::OrMap::OrMap(OrMap &&x)
{
    m_id = x.m_id;
    m_m = std::move(x.m_m);
    m_cbase = std::move(x.m_cbase);
}

IDL::OrMap& IDL::OrMap::operator=(const OrMap &x)
{

    m_id = x.m_id;
    m_m = x.m_m;
    m_cbase = x.m_cbase;

    return *this;
}

IDL::OrMap& IDL::OrMap::operator=(OrMap &&x)
{

    m_id = x.m_id;
    m_m = std::move(x.m_m);
    m_cbase = std::move(x.m_cbase);

    return *this;
}

size_t IDL::OrMap::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



        current_alignment += Mvreg::getMaxCdrSerializedSize(current_alignment);
    }

    current_alignment += DotContext::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t IDL::OrMap::getCdrSerializedSize(const OrMap& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.m())
    {
        (void)a;
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


        current_alignment += Mvreg::getCdrSerializedSize((a.second), current_alignment);

    }


    current_alignment += DotContext::getCdrSerializedSize(data.cbase(), current_alignment);

    return current_alignment - initial_alignment;
}

void IDL::OrMap::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_m;
    scdr << m_cbase;
}

void IDL::OrMap::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_m;
    dcdr >> m_cbase;
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void IDL::OrMap::id(int32_t _id)
{
m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t IDL::OrMap::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& IDL::OrMap::id()
{
    return m_id;
}

/*!
 * @brief This function copies the value in member m
 * @param _m New value to be copied in member m
 */
void IDL::OrMap::m(const std::map<int32_t, Mvreg> &_m)
{
m_m = _m;
}

/*!
 * @brief This function moves the value in member m
 * @param _m New value to be moved in member m
 */
void IDL::OrMap::m(std::map<int32_t, Mvreg> &&_m)
{
m_m = std::move(_m);
}

/*!
 * @brief This function returns a constant reference to member m
 * @return Constant reference to member m
 */
const std::map<int32_t, IDL::Mvreg>& IDL::OrMap::m() const
{
    return m_m;
}

/*!
 * @brief This function returns a reference to member m
 * @return Reference to member m
 */
std::map<int32_t, IDL::Mvreg>& IDL::OrMap::m()
{
    return m_m;
}
/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
void IDL::OrMap::cbase(const DotContext &_cbase)
{
m_cbase = _cbase;
}

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
void IDL::OrMap::cbase(DotContext &&_cbase)
{
m_cbase = std::move(_cbase);
}

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
const IDL::DotContext& IDL::OrMap::cbase() const
{
    return m_cbase;
}

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
IDL::DotContext& IDL::OrMap::cbase()
{
    return m_cbase;
}

size_t IDL::OrMap::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool IDL::OrMap::isKeyDefined()
{
   return false;
}

void IDL::OrMap::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
    (void) scdr;



}
