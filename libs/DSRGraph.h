//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.2
//
// <auto-generated>
//
// Generated from file `DSRGraph.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __DSRGraph_h__
#define __DSRGraph_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace RoboCompDSR
{

struct AttribValue
{
    ::std::string type;
    ::std::string value;
    int length;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const ::std::string&, const int&> ice_tuple() const
    {
        return std::tie(type, value, length);
    }
    bool operator==(const AttribValue &av_) const {
        if (this == &av_) {
            return true;
        }
        if (type != av_.type || value != av_.value || length != av_.length) {
            return false;
        }
        return true;
    }
    bool operator<(const AttribValue &av_) const {
        if (this == &av_) {
            return false;
        }
        if (value < av_.value) {
            return true;
        } else if (av_.value < value) {
            return false;
        }
        return false;
    }

    bool operator!=(const AttribValue &av_) const {
        return !operator==(av_);
    }

    bool operator<=(const AttribValue &av_) const {
        return operator<(av_) || operator==(av_);
    }

    bool operator>(const AttribValue &av_) const {
        return !operator<(av_) && !operator==(av_);
    }

    bool operator>=(const AttribValue &av_) const {
        return !operator<(av_);
    }

    friend std::ostream &operator<<(std::ostream &output, const AttribValue &av_) {
        output << "Type: "<<av_.type<<", Value["<<av_.length<<"]: "<<av_.value<<", ";
    return output;
    };

};

using Attribs = ::std::map<::std::string, AttribValue>;

struct EdgeAttribs
{
    ::std::string label;
    int from;
    int to;
    Attribs attrs;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const int&, const int&, const Attribs&> ice_tuple() const
    {
        return std::tie(label, from, to, attrs);
    }

    bool operator==(const EdgeAttribs &eA_) const {
        if (this == &eA_) {
            return true;
        }
        if (label != eA_.label || from != eA_.from || to != eA_.to || attrs != eA_.attrs) {
            return false;
        }
        return true;
    }

    bool operator<(const EdgeAttribs &eA_) const {
        if (this == &eA_) {
            return false;
        }
        if (label < eA_.label) {
            return true;
        } else if (eA_.label < label) {
            return false;
        }
        return false;
    }

    bool operator!=(const EdgeAttribs &eA_) const {
        return !operator==(eA_);
    }

    bool operator<=(const EdgeAttribs &eA_) const {
        return operator<(eA_) || operator==(eA_);
    }

    bool operator>(const EdgeAttribs &eA_) const {
        return !operator<(eA_) && !operator==(eA_);
    }

    bool operator>=(const EdgeAttribs &eA_) const {
        return !operator<(eA_);
    }

    friend std::ostream &operator<<(std::ostream &output, const EdgeAttribs &ea_) {
        output << "EdgeAttribs["<<ea_.label<<", from:" << ea_.from << "-> to:"<<ea_.to<<" Attribs:[";
        for (auto [k,v] : ea_.attrs)
            output << k <<":"<<v <<" - ";
        output<<"]]";
        return output;
    };

};

using FanOut = ::std::map<int, EdgeAttribs>;

struct Node
{
    ::std::string type;
    int id;
    Attribs attrs;
    FanOut fano;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const int&, const Attribs&, const FanOut&> ice_tuple() const
    {
        return std::tie(type, id, attrs, fano);
    }
    bool operator==(const Node &n_) const {
        if (this == &n_) {
            return true;
        }
        if (id != n_.id || type != n_.type || attrs != n_.attrs || fano != n_.fano) {
            return false;
        }
//        if (id != n_.id) {
//            return false;
//        }
        return true;
    }


    bool operator<(const Node &n_) const {
        if (this == &n_) {
            return false;
        }
        if (id < n_.id) {
            return true;
        } else if (n_.id < id) {
            return false;
        }
        return false;
    }

    bool operator!=(const Node &n_) const {
        return !operator==(n_);
    }

    bool operator<=(const Node &n_) const {
        return operator<(n_) || operator==(n_);
    }

    bool operator>(const Node &n_) const {
        return !operator<(n_) && !operator==(n_);
    }

    bool operator>=(const Node &n_) const {
        return !operator<(n_);
    }

    friend std::ostream &operator<<(std::ostream &output, const Node &n_) {
        output <<"Node:["<<n_.id<<"," << n_.type <<"], Attribs:[";
        for (auto [k,v] : n_.attrs)
            output << k <<":("<< v <<");";
        output<<"], FanOut:[";
        for (auto [k,v] : n_.fano)
            output << k <<":("<< v<<");";
        output << "]";
        return output;
    }
};

struct GraphRequest
{
    ::std::string from;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(from);
    }
};

struct PairInt
{
    int first;
    int second;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(first, second);
    }

    bool operator==(const PairInt &pi_) const {
        if (this == &pi_) {
            return true;
        }
        if (first != pi_.first || second != pi_.second) {
            return false;
        }
        return true;
    }

    bool operator<(const PairInt &pi_) const {
        if (this == &pi_) {
            return false;
        }
        if ( (first+second) < (pi_.first+pi_.second)) {
            return true;
        } else if ((first+second) > (pi_.first+pi_.second)) {
            return false;
        }
        return false;
    }

    bool operator!=(const PairInt &pi_) const {
        return !operator==(pi_);
    }

    bool operator<=(const PairInt &pi_) const {
        return operator<(pi_) || operator==(pi_);
    }

    bool operator>(const PairInt &pi_) const {
        return !operator<(pi_) && !operator==(pi_);
    }

    bool operator>=(const PairInt &pi_) const {
        return !operator<(pi_);
    }
    friend std::ostream &operator<<(std::ostream &output, const PairInt &pi_) {
        output <<"("<<pi_.first<<","<<pi_.second<<")";
        return output;
    }
};

using CausalContext = ::std::map<int, int>;

using DotCloud = ::std::vector<PairInt>;

using DotKernelValue = ::std::map<PairInt, Node>;

struct DotContext
{
    CausalContext cc;
    DotCloud dc;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const CausalContext&, const DotCloud&> ice_tuple() const
    {
        return std::tie(cc, dc);
    }
    friend std::ostream &operator<<(std::ostream &output, const DotContext &dc_) {
        output << ", CC: [";
        for (const auto & kv : dc_.cc)
            output <<" "<< kv.first << ":" << kv.second;
        output << "] , DC: [";
        for (const auto & kv : dc_.dc)
            output <<" "<< kv.first << ":" << kv.second;
        output << "] ";
        return output;
    }

};

struct DotKernel
{
    DotKernelValue ds;
    DotContext cbase;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const DotKernelValue&, const DotContext&> ice_tuple() const
    {
        return std::tie(ds, cbase);
    }
    friend std::ostream &operator<<(std::ostream &output, const DotKernel &dk_) {
        for (const auto & kv : dk_.ds)
            output << kv.first << "-->" << kv.second<< ", ";
        output <<dk_.cbase;
        return output;
    }
};

struct AworSet
{
    int id;
    DotKernel dk;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const int&, const DotKernel&> ice_tuple() const
    {
        return std::tie(id, dk);
    }

    friend std::ostream &operator<<(std::ostream &output, const AworSet &as_) {
        output <<"RoboCompDSR::AworSet: ID:["<<as_.id<<"], Data: ["<<as_.dk<<"] ";
        return output;
    }

};

using MapAworSet = ::std::map<int, AworSet>;

struct OrMap
{
    int id;
    MapAworSet m;
    DotContext cbase;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const int&, const MapAworSet&, const DotContext&> ice_tuple() const
    {
        return std::tie(id, m, cbase);
    }

    friend std::ostream &operator<<(std::ostream &output, const OrMap &om_) {
        output <<"RoboCompDSR::OrMap:"<<om_.id<<"\nMap: ";
        for (const auto & kv : om_.m)
            output << kv.first << "->" << kv.second << "\n";
        output << "\nContext: "<<om_.cbase;
        return output;
    }

};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::RoboCompDSR::AttribValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::AttribValue, S>
{
    static void read(S* istr, ::RoboCompDSR::AttribValue& v)
    {
        istr->readAll(v.type, v.value, v.length);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::EdgeAttribs>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::EdgeAttribs, S>
{
    static void read(S* istr, ::RoboCompDSR::EdgeAttribs& v)
    {
        istr->readAll(v.label, v.from, v.to, v.attrs);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::Node>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::Node, S>
{
    static void read(S* istr, ::RoboCompDSR::Node& v)
    {
        istr->readAll(v.type, v.id, v.attrs, v.fano);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::GraphRequest>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::GraphRequest, S>
{
    static void read(S* istr, ::RoboCompDSR::GraphRequest& v)
    {
        istr->readAll(v.from);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::PairInt>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompDSR::PairInt, S>
{
    static void read(S* istr, ::RoboCompDSR::PairInt& v)
    {
        istr->readAll(v.first, v.second);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::DotContext>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::DotContext, S>
{
    static void read(S* istr, ::RoboCompDSR::DotContext& v)
    {
        istr->readAll(v.cc, v.dc);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::DotKernel>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::DotKernel, S>
{
    static void read(S* istr, ::RoboCompDSR::DotKernel& v)
    {
        istr->readAll(v.ds, v.cbase);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::AworSet>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::AworSet, S>
{
    static void read(S* istr, ::RoboCompDSR::AworSet& v)
    {
        istr->readAll(v.id, v.dk);
    }
};

template<>
struct StreamableTraits<::RoboCompDSR::OrMap>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompDSR::OrMap, S>
{
    static void read(S* istr, ::RoboCompDSR::OrMap& v)
    {
        istr->readAll(v.id, v.m, v.cbase);
    }
};

}
/// \endcond

#else // C++98 mapping

namespace RoboCompDSR
{

struct AttribValue
{
    ::std::string type;
    ::std::string value;
    ::Ice::Int length;

    bool operator==(const AttribValue& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(type != rhs_.type)
        {
            return false;
        }
        if(value != rhs_.value)
        {
            return false;
        }
        if(length != rhs_.length)
        {
            return false;
        }
        return true;
    }

    bool operator<(const AttribValue& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(type < rhs_.type)
        {
            return true;
        }
        else if(rhs_.type < type)
        {
            return false;
        }
        if(value < rhs_.value)
        {
            return true;
        }
        else if(rhs_.value < value)
        {
            return false;
        }
        if(length < rhs_.length)
        {
            return true;
        }
        else if(rhs_.length < length)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const AttribValue& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const AttribValue& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const AttribValue& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const AttribValue& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::map< ::std::string, AttribValue> Attribs;

struct EdgeAttribs
{
    ::std::string label;
    ::Ice::Int from;
    ::Ice::Int to;
    Attribs attrs;
};

typedef ::std::map< ::Ice::Int, EdgeAttribs> FanOut;

struct Node
{
    ::std::string type;
    ::Ice::Int id;
    Attribs attrs;
    FanOut fano;
};

struct GraphRequest
{
    ::std::string from;

    bool operator==(const GraphRequest& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(from != rhs_.from)
        {
            return false;
        }
        return true;
    }

    bool operator<(const GraphRequest& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(from < rhs_.from)
        {
            return true;
        }
        else if(rhs_.from < from)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const GraphRequest& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const GraphRequest& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const GraphRequest& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const GraphRequest& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct PairInt
{
    ::Ice::Int first;
    ::Ice::Int second;

    bool operator==(const PairInt& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(first != rhs_.first)
        {
            return false;
        }
        if(second != rhs_.second)
        {
            return false;
        }
        return true;
    }

    bool operator<(const PairInt& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(first < rhs_.first)
        {
            return true;
        }
        else if(rhs_.first < first)
        {
            return false;
        }
        if(second < rhs_.second)
        {
            return true;
        }
        else if(rhs_.second < second)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const PairInt& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const PairInt& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const PairInt& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const PairInt& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::map< ::Ice::Int, ::Ice::Int> CausalContext;

typedef ::std::vector<PairInt> DotCloud;

typedef ::std::map<PairInt, Node> DotKernelValue;

struct DotContext
{
    CausalContext cc;
    DotCloud dc;
};

struct DotKernel
{
    DotKernelValue ds;
    DotContext cbase;
};

struct AworSet
{
    ::Ice::Int id;
    DotKernel dk;
};

typedef ::std::map< ::Ice::Int, AworSet> MapAworSet;

struct OrMap
{
    ::Ice::Int id;
    MapAworSet m;
    DotContext cbase;
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::RoboCompDSR::AttribValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::AttribValue, S>
{
    static void write(S* ostr, const ::RoboCompDSR::AttribValue& v)
    {
        ostr->write(v.type);
        ostr->write(v.value);
        ostr->write(v.length);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::AttribValue, S>
{
    static void read(S* istr, ::RoboCompDSR::AttribValue& v)
    {
        istr->read(v.type);
        istr->read(v.value);
        istr->read(v.length);
    }
};

template<>
struct StreamableTraits< ::RoboCompDSR::EdgeAttribs>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::EdgeAttribs, S>
{
    static void write(S* ostr, const ::RoboCompDSR::EdgeAttribs& v)
    {
        ostr->write(v.label);
        ostr->write(v.from);
        ostr->write(v.to);
        ostr->write(v.attrs);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::EdgeAttribs, S>
{
    static void read(S* istr, ::RoboCompDSR::EdgeAttribs& v)
    {
        istr->read(v.label);
        istr->read(v.from);
        istr->read(v.to);
        istr->read(v.attrs);
    }
};

template<>
struct StreamableTraits< ::RoboCompDSR::Node>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::Node, S>
{
    static void write(S* ostr, const ::RoboCompDSR::Node& v)
    {
        ostr->write(v.type);
        ostr->write(v.id);
        ostr->write(v.attrs);
        ostr->write(v.fano);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::Node, S>
{
    static void read(S* istr, ::RoboCompDSR::Node& v)
    {
        istr->read(v.type);
        istr->read(v.id);
        istr->read(v.attrs);
        istr->read(v.fano);
    }
};

template<>
struct StreamableTraits< ::RoboCompDSR::GraphRequest>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::GraphRequest, S>
{
    static void write(S* ostr, const ::RoboCompDSR::GraphRequest& v)
    {
        ostr->write(v.from);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::GraphRequest, S>
{
    static void read(S* istr, ::RoboCompDSR::GraphRequest& v)
    {
        istr->read(v.from);
    }
};

template<>
struct StreamableTraits< ::RoboCompDSR::PairInt>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::PairInt, S>
{
    static void write(S* ostr, const ::RoboCompDSR::PairInt& v)
    {
        ostr->write(v.first);
        ostr->write(v.second);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::PairInt, S>
{
    static void read(S* istr, ::RoboCompDSR::PairInt& v)
    {
        istr->read(v.first);
        istr->read(v.second);
    }
};

template<>
struct StreamableTraits< ::RoboCompDSR::DotContext>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::DotContext, S>
{
    static void write(S* ostr, const ::RoboCompDSR::DotContext& v)
    {
        ostr->write(v.cc);
        ostr->write(v.dc);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::DotContext, S>
{
    static void read(S* istr, ::RoboCompDSR::DotContext& v)
    {
        istr->read(v.cc);
        istr->read(v.dc);
    }
};

template<>
struct StreamableTraits< ::RoboCompDSR::DotKernel>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::DotKernel, S>
{
    static void write(S* ostr, const ::RoboCompDSR::DotKernel& v)
    {
        ostr->write(v.ds);
        ostr->write(v.cbase);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::DotKernel, S>
{
    static void read(S* istr, ::RoboCompDSR::DotKernel& v)
    {
        istr->read(v.ds);
        istr->read(v.cbase);
    }
};

template<>
struct StreamableTraits< ::RoboCompDSR::AworSet>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::AworSet, S>
{
    static void write(S* ostr, const ::RoboCompDSR::AworSet& v)
    {
        ostr->write(v.id);
        ostr->write(v.dk);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::AworSet, S>
{
    static void read(S* istr, ::RoboCompDSR::AworSet& v)
    {
        istr->read(v.id);
        istr->read(v.dk);
    }
};

template<>
struct StreamableTraits< ::RoboCompDSR::OrMap>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompDSR::OrMap, S>
{
    static void write(S* ostr, const ::RoboCompDSR::OrMap& v)
    {
        ostr->write(v.id);
        ostr->write(v.m);
        ostr->write(v.cbase);
    }
};

template<typename S>
struct StreamReader< ::RoboCompDSR::OrMap, S>
{
    static void read(S* istr, ::RoboCompDSR::OrMap& v)
    {
        istr->read(v.id);
        istr->read(v.m);
        istr->read(v.cbase);
    }
};

}
/// \endcond

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
